<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  particle vertex shader
//
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>

<$declareStandardTransform()$>

struct ParticleUniforms {
    vec4 color;         // rgba
    float radius;
    float firstPass;
    float iGlobalTime;
    float iDeltaTime;
    vec4 iResolution;   // iResolution.xy = texture size, z = maxParticles, w = spare
};

layout(std140) uniform particleBuffer {
    ParticleUniforms particle;
};

uniform sampler2D particlesTex;

out vec4 varColor;
out vec2 varTexCoord;

ivec2 getFragCoord(int index) {
    return ivec2(mod(index, particle.iResolution.x),
                 2 * int(index / particle.iResolution.x));
}

const int NUM_VERTICES_PER_PARTICLE = 3;
// Center the triangle around the particle
const vec4 UNIT_TRI[NUM_VERTICES_PER_PARTICLE] = vec4[NUM_VERTICES_PER_PARTICLE](
    vec4(-1.0, 3.0, 0.0, 0.0),
    vec4(-1.0, -1.0, 0.0, 0.0),
    vec4(3.0, -1.0, 0.0, 0.0)
);

void main(void) {
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();

    // Which particle are we dealing with
    int particleID = gl_VertexID / NUM_VERTICES_PER_PARTICLE;
    // Which quad vertex pos?
    int triID = gl_VertexID - particleID * NUM_VERTICES_PER_PARTICLE;

    // TODO: expose setColor(int index) function
    varColor = particle.color;

    // TODO: expose setRadius(int index) function
    float radius = particle.radius;

    // Pass the tex coords to the fragment shader
    varTexCoord = UNIT_TRI[triID].xy;

    vec4 quadPos = radius * UNIT_TRI[triID];

    // anchor point in eye space
    vec4 anchorPoint;
    vec4 _inPosition = vec4(texelFetch(particlesTex, getFragCoord(particleID), 0).xyz, 1.0);
    <$transformModelToEyePos(cam, obj, _inPosition, anchorPoint)$>

    vec4 eyePos = anchorPoint + quadPos;
    <$transformEyeToClipPos(cam, eyePos, gl_Position)$>
}