<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  particle vertex shader
//
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>

<$declareStandardTransform()$>

struct ParticleUniforms {
    float radius;
    vec4 color; // rgba
    bool firstPass;
    float iGlobalTime;
    float iDeltaTime;
    vec2 iResolution;
    float maxParticles;
};

layout(std140) uniform particleBuffer {
    ParticleUniforms particle;
};

uniform sampler2D particlesTex;

out vec4 varColor;
out vec2 varTexcoord;

vec2 getFragCoord(float index) {
    return vec2(mod(index, particle.iResolution.x - 1.0),
                2.0*floor(index / (particle.iResolution.x - 1.0)));
}

const int NUM_VERTICES_PER_PARTICLE = 3;
// This ordering ensures that un-rotated particles render upright in the viewer.
const vec4 UNIT_TRI[NUM_VERTICES_PER_PARTICLE] = vec4[NUM_VERTICES_PER_PARTICLE](
    vec4(-1.0, 1.0, 0.0, 0.0),
    vec4(-1.0, -1.0, 0.0, 0.0),
    vec4(1.0, -1.0, 0.0, 0.0)
);

void main(void) {
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();

    // Which icon are we dealing with ?
    int particleID = gl_VertexID / NUM_VERTICES_PER_PARTICLE;
    // Which quad vertex pos?
    int triID = gl_VertexID - particleID * NUM_VERTICES_PER_PARTICLE;

    // Particle properties
//    float age = inColor.x / particle.lifespan.x;

    // Pass the texcoord and the z texcoord is representing the texture icon
    // Offset for corrected vertex ordering.
    varTexcoord = (UNIT_TRI[triID].xy - 1.0) * vec2(0.5, -0.5);

    // TODO: expose setColor(int index) function
    varColor = particle.color;

    // anchor point in eye space
    // TODO: expose setRadius(int index) function
    float radius = particle.radius;
    vec4 quadPos = 0.5 * UNIT_QUAD[twoTriID];

    vec4 anchorPoint;
    vec4 _inPosition = vec4(texture(particlesTex, getFragCoord(particleID) / particle.iResolution).xyz, 1.0);
    <$transformModelToEyePos(cam, obj, _inPosition, anchorPoint)$>

    vec4 eyePos = anchorPoint + quadPos;
    <$transformEyeToClipPos(cam, eyePos, gl_Position)$>
}
