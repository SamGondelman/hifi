<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  particle vertex shader
//
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>

<$declareStandardTransform()$>

struct ParticleUniforms {
    vec4 color;         // rgba
    float radius;
    float firstPass;
    float iGlobalTime;
    float iDeltaTime;
    vec4 iResolution;   // iResolution.xy = texture size, z = maxParticles, w = spare
};

layout(std140) uniform particleBuffer {
    ParticleUniforms particle;
};

uniform sampler2D particlesTex;

out vec4 varColor;
out vec2 varTexCoord;

ivec2 getFragCoord(int index) {
    return ivec2(mod(index, particle.iResolution.x),
                 2 * int(index / particle.iResolution.x));
}

const int NUM_VERTICES_PER_PARTICLE = 3;
// Center the triangle around the particle
const vec4 UNIT_TRI[NUM_VERTICES_PER_PARTICLE] = vec4[NUM_VERTICES_PER_PARTICLE](
    vec4(-1.0, 3.0, 0.0, 0.0),
    vec4(-1.0, -1.0, 0.0, 0.0),
    vec4(3.0, -1.0, 0.0, 0.0)
);

#define HIFI_DRAW_METHODS

void main(void) {
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();

    // Which particle are we dealing with
    int particleID = gl_VertexID / NUM_VERTICES_PER_PARTICLE;
    // Which quad vertex pos?
    int triID = gl_VertexID - particleID * NUM_VERTICES_PER_PARTICLE;

    ivec2 iFragCoord = getFragCoord(particleID);
    vec4 pos = texelFetch(particlesTex, iFragCoord, 0);
    vec4 vel = texelFetch(particlesTex, iFragCoord + ivec2(0, 1), 0);

    varColor = setColor(pos, vel, particleID, iFragCoord);
    float radius = setRadius(pos, vel, particleID, iFragCoord);

    radius = 0.25;

    // Pass the tex coords to the fragment shader
    varTexCoord = UNIT_TRI[triID].xy;

    vec4 quadPos = radius * UNIT_TRI[triID];

    // anchor point in eye space
    vec4 anchorPoint;
    vec4 _inPosition = vec4(pos.xyz, 1.0);
    //_inPosition = vec4(vec3(iFragCoord.x, 0, iFragCoord.y)/(20.0) + vec3(0, cos(particle.iGlobalTime + particleID), 0), 1);
    <$transformModelToEyePos(cam, obj, _inPosition, anchorPoint)$>

    vec4 eyePos = anchorPoint + quadPos;
    <$transformEyeToClipPos(cam, eyePos, gl_Position)$>
}