<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//  fragment shader
//
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

// Constants
const float dt = 0.0167;
const float FLT_MAX = 1.0 / 0.000000000001;
const vec3 UP = vec3(0.0, 1.0, 0.0);

struct ParticleUniforms {
    vec4 color;         // rgba
    float radius;
    float firstPass;
    float iGlobalTime;
    float iDeltaTime;
    vec4 iResolution;   // iResolution.xy = texture size, z = maxParticles, w = spare
};

layout(std140) uniform particleBuffer {
    ParticleUniforms particle;
};

uniform sampler2D particlesTex;

const int NUM_OBJECTS = 2;
vec4 objects[2 * NUM_OBJECTS] = vec4[](
vec4(5),
vec4(1),
vec4(10),
vec4(1)
);

// output from DrawUnitQuadTexcoord
in vec2 varTexCoord0;

out vec4 fragColor;

// Helpers
float hash(float n) { return fract(sin(n)*753.5453123); }

ivec2 getFragCoord(int index) {
    return ivec2(mod(index, particle.iResolution.x),
                 2 * int(index / particle.iResolution.x));
}

const float SCALE = 10.0;

vec4 initPosition(int index) {
    // Particles start off dead
    const float MIN_LIFETIME = 2.0;
    const float PARTICLE_LIFETIME = 5.0;

    return vec4(vec3(0.0), MIN_LIFETIME + PARTICLE_LIFETIME * hash(index*7344.0));
}

vec4 initVelocity(int index) {
    // Particles start off dead
    return vec4(vec3(0.0), FLT_MAX);
}

vec4 updatePosition(vec4 pos, vec4 vel, int index, ivec2 iFragCoord) {
    if (vel.w == FLT_MAX && pos.w > 0.0) {
        // If this particle just died, move it to be near an unrezzed object
        int object = int(hash(index*1692.0 + particle.iGlobalTime) * NUM_OBJECTS);
        vec4 objPos = objects[2 * object];
        vec3 objDim = objects[2 * object + 1].xyz;

        if (particle.iGlobalTime < objPos.w) {
            const float ORBIT_DIM_RATIO = 2.0;
            vec3 offset = objDim * ORBIT_DIM_RATIO * vec3(hash(index*872.0 + particle.iGlobalTime) - 0.5,
                                                          hash(index*1667.0 + particle.iGlobalTime) - 0.5,
                                                          hash(index*23589.0 + particle.iGlobalTime) - 0.5);

            pos = vec4(objPos.xyz + offset, -pos.w);
        }
    } else if (vel.w < FLT_MAX && pos.w < 0.0) {
        pos.w = -pos.w;
    } else if (vel.w < FLT_MAX && pos.w > 0.0) {
        // Otherwise, move by dx
        pos += vec4(vel.xyz * dt, 0.0);
    }

    return pos;
}

vec4 updateVelocity(vec4 pos, vec4 vel, int index, ivec2 iFragCoord) {
    vec3 minR;
    float minD2 = FLT_MAX;
    int numUnrezzed = 0;

    // pull particles towards nearest object
    for (int i = 0; i < NUM_OBJECTS; i++) {
        vec4 posTime = objects[2 * i];
        if (particle.iGlobalTime > posTime.w) {
            continue;
        }

        vec3 r = posTime.xyz - pos.xyz;
        float d2 = dot(r, r);
        numUnrezzed++;

        if (d2 < minD2) {
            minR = r;
            minD2 = d2;
        }
    }

    if (minD2 != FLT_MAX) {
        const float G = 25.0;
        const float SQRT_G = 5.0;
        float d = sqrt(minD2);
        if (pos.w < 0.0) {
            float velMag = SQRT_G/sqrt(d);
            vel.xyz = velMag*normalize(cross(UP, -minR));
        } else {
            vel.xyz += G/(d * minD2)* minR * dt;

            if (vel.w < pos.w) {
                // Particle still alive (die off quickly if no unrezzed objects)
                vel.w += dt;
            } else if (vel.w < FLT_MAX) {
                // Particle died
                vel = vec4(FLT_MAX);
            } else {
                // Particle reborn
                vel.w = 0.0;
            }
        }
    } else {
        // Die quickly if there are no objects left
        const float FAST_DEATH_SPEED = 3.0;
        vel.w += dt * FAST_DEATH_SPEED;
    }

    // TODO: this should depend on the size of the object
    const float MAX_VEL = 7.5;
    vel.x = abs(vel.x) > MAX_VEL ? sign(vel.x) * MAX_VEL : vel.x;
    vel.y = abs(vel.y) > MAX_VEL ? sign(vel.y) * MAX_VEL : vel.y;
    vel.z = abs(vel.z) > MAX_VEL ? sign(vel.z) * MAX_VEL : vel.z;

    return vel;
}

void main(void) {
    ivec2 iFragCoord = ivec2(varTexCoord0 * particle.iResolution.xy);
    int index = int(iFragCoord.x + iFragCoord.y * particle.iResolution.x / 2.0);

    // TODO: split position and velocity into two renderbuffers
    ivec2 particleBounds = getFragCoord(int(particle.iResolution.z) - 1);
    bool top = (iFragCoord.y == particleBounds.y || iFragCoord.y == particleBounds.y + 1);
    particleBounds.x = top ? particleBounds.x : (int(particle.iResolution.x) - 1);

    if (iFragCoord.x <= particleBounds.x) {
        // Even rows are positions, odd rows are velocities
        if (mod(iFragCoord.y, 2) == 0) {
            if (particle.firstPass > 0.5) {
                fragColor = initPosition(index);
            } else {
                vec4 pos = texelFetch(particlesTex, iFragCoord, 0);
                vec4 vel = texelFetch(particlesTex, iFragCoord + ivec2(0, 1), 0);
                fragColor = updatePosition(pos, vel, index, iFragCoord);
            }
        } else {
            if (particle.firstPass > 0.5) {
                fragColor = initVelocity(index);
            } else {
                vec4 pos = texelFetch(particlesTex, iFragCoord - ivec2(0, 1), 0);
                vec4 vel = texelFetch(particlesTex, iFragCoord, 0);
                fragColor = updateVelocity(pos, vel, index, iFragCoord);
            }
        }
    } else {
        discard;
    }
}
