<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//  fragment shader
//
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

// Constants
const float dt = 0.0167;
const float FLT_MAX = 1.0 / 0.000000000001;
const vec3 UP = vec3(0.0, 1.0, 0.0);

struct ParticleUniforms {
    vec4 color;         // rgba
    float radius;
    float firstPass;
    float iGlobalTime;
    float iDeltaTime;
    vec4 iResolution;   // iResolution.xy = texture size, z = maxParticles, w = spare
};

layout(std140) uniform particleBuffer {
    ParticleUniforms particle;
};

uniform sampler2D particlesTex;

// TODO: make this a texture buffer to allow for variable length inputs without a capped maximum
//layout(std140) uniform hifiBuffer {
#define HIFI_UPDATE_UNIFORMS
//};

// output from DrawUnitQuadTexcoord
in vec2 varTexCoord0;

out vec4 fragColor;

ivec2 getFragCoord(int index) {
    return ivec2(mod(index, particle.iResolution.x),
                 2 * int(index / particle.iResolution.x));
}

#define HIFI_UPDATE_METHODS

void main(void) {
    ivec2 iFragCoord = ivec2(varTexCoord0 * particle.iResolution.xy);
    int index = int(iFragCoord.x + iFragCoord.y * particle.iResolution.x / 2.0);

    // TODO: split position and velocity into two renderbuffers
    ivec2 particleBounds = getFragCoord(int(particle.iResolution.z) - 1);
    bool top = (iFragCoord.y == particleBounds.y || iFragCoord.y == particleBounds.y + 1);
    particleBounds.x = top ? particleBounds.x : (int(particle.iResolution.x) - 1);

    if (iFragCoord.x <= particleBounds.x) {
        // Even rows are positions, odd rows are velocities
        if (mod(iFragCoord.y, 2) == 0) {
            if (particle.firstPass > 0.5) {
                fragColor = initPosition(index);
            } else {
                vec4 pos = texelFetch(particlesTex, iFragCoord, 0);
                vec4 vel = texelFetch(particlesTex, iFragCoord + ivec2(0, 1), 0);
                fragColor = updatePosition(pos, vel, index, iFragCoord);
            }
        } else {
            if (particle.firstPass > 0.5) {
                fragColor = initVelocity(index);
            } else {
                vec4 pos = texelFetch(particlesTex, iFragCoord - ivec2(0, 1), 0);
                vec4 vel = texelFetch(particlesTex, iFragCoord, 0);
                fragColor = updateVelocity(pos, vel, index, iFragCoord);
            }
        }
    } else {
        discard;
    }
}
